/***************************************************************************//**
* \file pse84_ns_cm33.ld
* \version 1.0.0
*
* Linker file for the GNU C compiler.
*
* The main purpose of the linker script is to describe how the sections in the
* input files should be mapped into the output file, and to control the memory
* layout of the output file.
*
* \note The entry point location starts at 0x14000000. The valid
* application image should be placed there.
*
* \note The linker files included with the PDL template projects must be generic
* and handle all common use cases. Your project may not use every section
* defined in the linker files. In that case you may see warnings during the
* build process. In your project, you can simply comment out or remove the
* relevant code in the linker file.
*
********************************************************************************
* \copyright
* Copyright (c) (2020-2025), Cypress Semiconductor Corporation (an Infineon company) or
* an affiliate of Cypress Semiconductor Corporation.
* SPDX-License-Identifier: Apache-2.0
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*******************************************************************************/
/* Specify the output format for the linker script */
OUTPUT_FORMAT ("elf32-littlearm", "elf32-bigarm", "elf32-littlearm")
/* Search for libraries in the current directory */
SEARCH_DIR(.)
/* Specify the group of libraries to link against */
GROUP(-lgcc -lc -lnosys)
/* Define the entry point of the program, which is the reset handler */
ENTRY(Reset_Handler)

/* Define the stack size for the application */
PROVIDE(__StackSize = 0x1000);

/* Include the device memory definitions generated by the Device Configurator */
INCLUDE cymem_gnu_CM33_0.ld

/* The start address and size of shared memory sub-block in shared memory region for the current core
 * The approach is to have an equal sub-block for each core to avoid shared objects to be overlapped.
 * Default configuration: A sub-block for CM33_NS shared data will be 2nd.
 */
 CORE_SYSTEM_SHARED_MEM_SIZE   = (CYMEM_CM33_0_m33_m55_system_shared_SIZE / 3);
 CORE_SYSTEM_SHARED_MEM_START  = (CYMEM_CM33_0_m33_m55_system_shared_START + CORE_SYSTEM_SHARED_MEM_SIZE);


/* Define the memory layout */
MEMORY
{
    /* Include the memory regions generated by the Device Configurator.
       This file contains the memory region definitions for the device,
       which are used to define the memory layout in this linker script. */
    INCLUDE cymem_gnu_regions_CM33_0.ld

    /* The start address and size of shared memory sub-block in shared memory region */
    core_shared_memory : ORIGIN = CORE_SYSTEM_SHARED_MEM_START, LENGTH = CORE_SYSTEM_SHARED_MEM_SIZE
}

/* Linker script to place sections and symbol values. Should be used together
 * with other linker script that defines memory regions FLASH and RAM.
 * It references following symbols, which must be defined in code:
 *   Reset_Handler : Entry of reset handler
 *
 * It defines following symbols, which code can use without definition:
 *   __exidx_start
 *   __exidx_end
 *   __copy_table_start__
 *   __copy_table_end__
 *   __zero_table_start__
 *   __zero_table_end__
 *   __data_start__
 *   __preinit_array_start
 *   __preinit_array_end
 *   __init_array_start
 *   __init_array_end
 *   __fini_array_start
 *   __fini_array_end
 *   __data_end__
 *   __bss_start__
 *   __bss_end__
 *   __end__
 *   end
 *   __HeapLimit
 *   __StackLimit
 *   __StackTop
 *   __stack
 */

/* Device definitions */
VECTORS_ALIGNMENT = 1024;
m33_nvm_C_Offset = ORIGIN(m33_nvm_C) - ORIGIN(m33_nvm);
m33_code_C_Offset = ORIGIN(m33_code_C) - ORIGIN(m33_code);
m33_data_C_Offset = ORIGIN(m33_data_C) - ORIGIN(m33_data);

/* The size of the MCU boot header area at the start of the code region */
MCUBOOT_HEADER_SIZE = 0x400;

/* Define the sections */
SECTIONS
{
    /* This section is intended to reserve a space for MCUBoot header in LMA address space */
    .mcu_boot_header_lma(NOLOAD) : ALIGN(MCUBOOT_HEADER_SIZE)
    {
        . += MCUBOOT_HEADER_SIZE;
    } > m33_nvm

    /* This section is intended to reserve a space for MCUBoot header in VMA address space */
    .mcu_boot_header_vma(NOLOAD) : ALIGN(MCUBOOT_HEADER_SIZE)
    {
        . += MCUBOOT_HEADER_SIZE;
    } > m33_nvm_C

    /* This section is intended to hold the main non-secure (NS) application code for the Cortex-M33 */
    .app_code_main : ALIGN(VECTORS_ALIGNMENT)
    {
        /* Keep the vector table */
        KEEP(*(.vectors))
        /* Keep initializers */
        KEEP(*(.init))
        /* Keep finalizers */
        KEEP(*(.fini))
        /* Static constructors */
        *crtbegin.*(.ctors)
        *crtbegin?.*(.ctors)
        *(EXCLUDE_FILE(*crtend?.* *crtend.*) .ctors)
        *(SORT(.ctors.*))
        *(.ctors)
        /* Static destructors and atexit() */
        *crtbegin.*(.dtors)
        *crtbegin?.*(.dtors)
        *(EXCLUDE_FILE(*crtend?.* *crtend.*) .dtors)
        *(SORT(.dtors.*))
        *(.dtors)

        . = ALIGN(4);

        /* Array of pointers to preinint functions */
        PROVIDE_HIDDEN(__preinit_array_start = .);

        KEEP(*(.preinit_array))

        PROVIDE_HIDDEN(__preinit_array_end = .);

        . = ALIGN(4);

        /* Array of pointers to init functions */
        PROVIDE_HIDDEN(__init_array_start = .);

        KEEP(*(SORT(.init_array.*)))
        KEEP(*(.init_array))

        PROVIDE_HIDDEN(__init_array_end = .);

        . = ALIGN(4);

        /* Array of pointers to finalizer functions */

        PROVIDE_HIDDEN(__fini_array_start = .);

        KEEP(*(SORT(.fini_array.*)))
        KEEP(*(.fini_array))

        PROVIDE_HIDDEN(__fini_array_end = .);

        /* Read only code (constants) */
        *(.rodata .rodata.* .constdata .constdata.* .conststring .conststring.*)
        /* Exclude certain files from this section as they will be placed in RAM */
        *(EXCLUDE_FILE(*cy_syslib.* *cy_syslib_ext.* *cy_smif.* *cy_smif_memslot.* *cy_smif_sfdp.* *cy_smif_hb_flash.* *cyhal_qspi.* *mtb_hal_memoryspi.* *mtb_serial_memory.* *freertos/Source/*.* *clib-support/*.* *abstraction-rtos/*.* */cmsis/*.*) .text*)

        /* Check for load address mismatch */
        ASSERT(
            ADDR(.app_code_main) - ORIGIN(m33_nvm_C) == LOADADDR(.app_code_main) - ORIGIN(m33_nvm),
            "There is a load address mismatch for .app_code_main. The section offset within the VMA region does not match the section offset within the LMA region."
        );
    } > m33_nvm_C AT > m33_nvm

    /* Exception tables for ARM architecture */
    .ARM.extab : ALIGN(4)
    {
        *(.ARM.extab* .gnu.linkonce.armextab.*)

        /* Check for load address mismatch */
        ASSERT(
            ADDR(.ARM.extab) - ORIGIN(m33_nvm_C) == LOADADDR(.ARM.extab) - ORIGIN(m33_nvm),
            "There is a load address mismatch for .ARM.extab. The section offset within the VMA region does not match the section offset within the LMA region."
        );
    } > m33_nvm_C AT > m33_nvm

    /* Exception index tables for ARM architecture */
    .ARM.exidx : ALIGN(4)
    {
        __exidx_start = .;

        *(.ARM.exidx* .gnu.linkonce.armexidx.*)

        __exidx_end = .;

        /* Check for load address mismatch */
        ASSERT(
            ADDR(.ARM.exidx) - ORIGIN(m33_nvm_C) == LOADADDR(.ARM.exidx) - ORIGIN(m33_nvm),
            "There is a load address mismatch for .ARM.exidx. The section offset within the VMA region does not match the section offset within the LMA region."
        );
    } > m33_nvm_C AT > m33_nvm

    /* Define copying of data from flash memory to RAM during the startup */
    .copy.table : ALIGN(4)
    {
        __copy_table_start__ = .;

        /* Performance-sensitive or critical functions that must be executed in SRAM */
        LONG(LOADADDR(.cy_sram_code) + m33_nvm_C_Offset)  /* From C-Bus addr */
        LONG(ADDR(.cy_sram_code) - m33_data_C_Offset)      /* To S-Bus addr */
        LONG(SIZEOF(.cy_sram_code)/4)                       /* Size in words */

        /* An initialized data in SRAM (First slot) */
        LONG (LOADADDR(.data) + m33_nvm_C_Offset)         /* From C-Bus addr */
        LONG (ADDR(.data))                                  /* To S-Bus addr */
        LONG (SIZEOF(.data)/4)                              /* Size in words */

        /* Performance-sensitive or critical functions that need to be executed in SRAM */
        LONG(LOADADDR(.app_code_ram) + m33_nvm_C_Offset)     /* From C-Bus addr */
        LONG(ADDR(.app_code_ram) - m33_code_C_Offset)         /* To S-Bus addr */
        LONG(SIZEOF(.app_code_ram)/4)                          /* Size in words */

        __copy_table_end__ = .;

        /* Check for load address mismatch */
        ASSERT(
            ADDR(.copy.table) - ORIGIN(m33_nvm_C) == LOADADDR(.copy.table) - ORIGIN(m33_nvm),
            "There is a load address mismatch for .copy.table. The section offset within the VMA region does not match the section offset within the LMA region."
        );
    } > m33_nvm_C AT > m33_nvm

    /* Define zeroing of the uninitialized data section */
    .zero.table : ALIGN(4)
    {
        __zero_table_start__ = .;

        LONG(__bss_start__)                       /* Start of the zero-initialized data section */
        LONG((__bss_end__ - __bss_start__)/4)     /* Size of the zero-initialized data section in words */

        __zero_table_end__ = .;

        /* Check for load address mismatch */
        ASSERT(
            ADDR(.zero.table) - ORIGIN(m33_nvm_C) == LOADADDR(.zero.table) - ORIGIN(m33_nvm),
            "There is a load address mismatch for .zero.table. The section offset within the VMA region does not match the section offset within the LMA region."
        );
    } > m33_nvm_C AT > m33_nvm

    /* A section for performance-sensitive or critical functions that need to be executed in SRAM */
    .app_code_ram : ALIGN(4)
    {
        KEEP(*(.cy_sram1_code))
        KEEP(*(.cy_ramfunc))
        KEEP(*(.text.cy_os_common))
        *cy_syslib_ext.*(.text*)
        *cy_syslib.*(.text*)
        *cy_smif.*(.text*)
        *cy_smif_memslot.*(.text*)
        *cy_smif_sfdp.*(.text*)
        *cy_smif_hb_flash.*(.text*)
        *cyhal_qspi.*(.text*)
        *mtb_hal_memoryspi.*(.text*)
        *mtb_serial_memory.*(.text*)
        *freertos/Source/*.*(.text*)
        *clib-support/*.*(.text*)
        *abstraction-rtos/*.*(.text*)
        */cmsis/*.*(.text*)

        . = ALIGN(4);
    } > m33_code_C AT > m33_nvm


    /* A section for the vector table */
    .ram_vectors (NOLOAD) : ALIGN(VECTORS_ALIGNMENT)
    {
        KEEP(*(.ram_vectors))
    } > m33_data

    /* A section for performance-sensitive or critical functions that must be executed in SRAM */
    .cy_sram_code : ALIGN(4)
    {
        KEEP(*(.cy_sram_code))
        KEEP(*(.text.cy_os_common))

        . = ALIGN(4);
    } > m33_data_C AT > m33_nvm

    /* A section for initialized data memory */
    .data : ALIGN(4)
    {
        __data_start__ = .;

        /* Data memory */
        *(.data*)
        KEEP(*(.jcr*))

        . = ALIGN(4);

        __data_end__ = .;
    } > m33_data AT > m33_nvm

    /* A section for non-initialized data memory */
    .bss(NOLOAD) : ALIGN(4)
    {
        __bss_start__ = .;

        *(.bss*)
        *(COMMON)

        . = ALIGN(4);

        __bss_end__ = .;
    } > m33_data

    /* A section for variables that should not be initialized during the device startup */
    .noinit (NOLOAD) :
    {
        KEEP(*(.noinit))
    } > m33_data

    /* A section for the heap memory */
    .heap(NOLOAD) : ALIGN(8)
    {
        __HeapBase = .;
        __end__ = .;
        end = __end__;

        KEEP(*(.heap*))

        . = ORIGIN(m33_data) + LENGTH(m33_data) - __StackSize;
        __HeapLimit = .;
    } > m33_data

    /* Define stack top, and stack limit */
    __StackTop = ORIGIN(m33_data) + LENGTH(m33_data);
    __StackLimit = __StackTop - __StackSize;
    PROVIDE(__stack = __StackTop);

    /* Check if data + heap + stack exceeds RAM limit */
    ASSERT(
        __StackLimit >= __HeapLimit,
        "Error: m33_data region overflowed with stack. Ensure that the stack size is within the available RAM."
    )

    /* A section for shared RAM memory */
    .cy_sharedmem(NOLOAD) : ALIGN(4)
    {
        KEEP(*(.cy_sharedmem))

        . = ALIGN(4);
    } > core_shared_memory

    /* A section for shared SOC memory */
    .cy_shared_socmem (NOLOAD) : ALIGN(4)
    {
        KEEP(*(.cy_shared_socmem))

        . = ALIGN(4);
    } > m33_m55_shared


    /* A section for the GPU buffer */
    .cy_gpu_buf(NOLOAD) :
    {
        KEEP(*(.cy_gpu_buf))
    }  > gfx_mem

}

