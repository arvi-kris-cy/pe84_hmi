/***************************************************************************//**
* \file pse84_s_cm33.ld
* \version 1.0.0
*
* Linker file for the GNU C compiler.
*
* The main purpose of the linker script is to describe how the sections in the
* input files should be mapped into the output file, and to control the memory
* layout of the output file.
*
* \note The entry point location starts at 0x14000000. The valid
* application image should be placed there.
*
* \note The linker files included with the PDL template projects must be generic
* and handle all common use cases. Your project may not use every section
* defined in the linker files. In that case you may see warnings during the
* build process. In your project, you can simply comment out or remove the
* relevant code in the linker file.
*
********************************************************************************
* \copyright
* Copyright (c) (2020-2025), Cypress Semiconductor Corporation (an Infineon company) or
* an affiliate of Cypress Semiconductor Corporation.
* SPDX-License-Identifier: Apache-2.0
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*******************************************************************************/
/* Specify the output format for the linker script */
OUTPUT_FORMAT ("elf32-littlearm", "elf32-bigarm", "elf32-littlearm")
/* Search for libraries in the current directory */
SEARCH_DIR(.)
/* Specify the group of libraries to link against */
GROUP(-lgcc -lc -lnosys)
/* Define the entry point of the program, which is the reset handler */
ENTRY(S_Reset_Handler)


/* Define the stack size for the application */
PROVIDE(__StackSize = 0x1000);

/* Include the device memory definitions generated by the Device Configurator */
INCLUDE cymem_gnu_CM33_0_S.ld

/* The start address and size of shared memory sub-block in shared memory region for the current core
 * The approach is to have an equal sub-block for each core to avoid shared objects to be overlapped.
 * Default configuration: A sub-block for CM33_S shared data will be 1st.
 */
 CORE_SYSTEM_SHARED_MEM_SIZE   = (CYMEM_CM33_0_S_m33_m55_system_shared_SIZE / 3);
 CORE_SYSTEM_SHARED_MEM_START  = (CYMEM_CM33_0_S_m33_m55_system_shared_S_START);

/* Define the memory layout */
MEMORY
{
    /* Include the memory regions generated by the Device Configurator.
       This file contains the memory region definitions for the device,
       which are used to define the memory layout in this linker script. */
    INCLUDE cymem_gnu_regions_CM33_0_S.ld

    /* The start address and size of shared memory sub-block in shared memory region */
    core_shared_memory : ORIGIN = CORE_SYSTEM_SHARED_MEM_START, LENGTH = CORE_SYSTEM_SHARED_MEM_SIZE
}

/* Linker script to place sections and symbol values. Should be used together
 * with other linker script that defines memory regions FLASH and RAM.
 * It references following symbols, which must be defined in code:
 *   Reset_Handler : Entry of reset handler
 *
 * It defines following symbols, which code can use without definition:
 *   __exidx_start
 *   __exidx_end
 *   __copy_table_start__
 *   __copy_table_end__
 *   __zero_table_start__
 *   __zero_table_end__
 *   __data_start__
 *   __preinit_array_start
 *   __preinit_array_end
 *   __init_array_start
 *   __init_array_end
 *   __fini_array_start
 *   __fini_array_end
 *   __data_end__
 *   __bss_start__
 *   __bss_end__
 *   __end__
 *   end
 *   __HeapLimit
 *   __StackLimit
 *   __StackTop
 *   __stack
 */

/* Device definitions */
VECTORS_ALIGNMENT = 1024;
m33s_code_C_S_Offset = ORIGIN(m33s_code_C_S) - ORIGIN(m33s_code_S);

/* The size of the MCU boot header area at the start of FLASH */
MCUBOOT_HEADER_SIZE = 0x400;

/* Define the sections */
SECTIONS
{
    /* This section is intended to reserve a space for MCUBoot header */
    .mcu_boot_header(NOLOAD) : ALIGN(MCUBOOT_HEADER_SIZE)
    {
        . += MCUBOOT_HEADER_SIZE;
    } > m33s_nvm_C_S

    /* This section is intended to hold the main secure (S) application code for the Cortex-M33 */
    .app_code_main : ALIGN(VECTORS_ALIGNMENT)
    {
        /* Keep the vector table */
        KEEP(*(.vectors))
        /* Keep initializers */
        KEEP(*(.init))
        /* Keep finalizers */
        KEEP(*(.fini))
        /* Static constructors */
        *crtbegin.*(.ctors)
        *crtbegin?.*(.ctors)
        *(EXCLUDE_FILE(*crtend?.* *crtend.*) .ctors)
        *(SORT(.ctors.*))
        *(.ctors)
        /* Static destructors and atexit() */
        *crtbegin.*(.dtors)
        *crtbegin?.*(.dtors)
        *(EXCLUDE_FILE(*crtend?.* *crtend.*) .dtors)
        *(SORT(.dtors.*))
        *(.dtors)

        . = ALIGN(4);

        /* Array of pointers to preinint functions */
        PROVIDE_HIDDEN(__preinit_array_start = .);

        KEEP(*(.preinit_array))

        PROVIDE_HIDDEN(__preinit_array_end = .);

        . = ALIGN(4);

        /* Array of pointers to init functions */
        PROVIDE_HIDDEN(__init_array_start = .);

        KEEP(*(SORT(.init_array.*)))
        KEEP(*(.init_array))

        PROVIDE_HIDDEN(__init_array_end = .);

        . = ALIGN(4);

        /* Array of pointers to finalizer functions */

        PROVIDE_HIDDEN(__fini_array_start = .);

        KEEP(*(SORT(.fini_array.*)))
        KEEP(*(.fini_array))

        PROVIDE_HIDDEN(__fini_array_end = .);

        /* Read only code (constants) */
        *(.rodata .rodata.* .constdata .constdata.* .conststring .conststring.*)
        /* Exclude certain files from this section as they will be placed in RAM */
        *(EXCLUDE_FILE(*cy_syslib.* *cy_syslib_ext.* *cy_smif.* *cy_smif_memslot.* *cy_smif_sfdp.* *cy_smif_hb_flash.* *cyhal_qspi.* *mtb_hal_memoryspi.* *mtb_serial_memory.*) .text*)
    } > m33s_nvm_C_S

    /* Exception tables for ARM architecture */
    .ARM.extab :
    {
        *(.ARM.extab* .gnu.linkonce.armextab.*)
    } > m33s_nvm_C_S

    /* Exception index tables for ARM architecture */
    .ARM.exidx :
    {
        __exidx_start = .;

        *(.ARM.exidx* .gnu.linkonce.armexidx.*)

        __exidx_end = .;
    } > m33s_nvm_C_S


    /* Define copying of data from flash memory to RAM during the startup */
    .copy.table : ALIGN(4)
    {
        __copy_table_start__ = .;

        LONG (LOADADDR(.data))                      /* From C-Bus addr */
        LONG (ADDR(.data))                          /* To S-Bus addr */
        LONG (SIZEOF(.data)/4)                      /* Size in words */

        LONG(LOADADDR(.app_code_ram))                  /* From C-Bus addr */
        LONG(ADDR(.app_code_ram) - m33s_code_C_S_Offset)  /* To S-Bus addr */
        LONG(SIZEOF(.app_code_ram)/4)                  /* Size in words */

        __copy_table_end__ = .;
    } > m33s_nvm_C_S

    /* Define zeroing of the uninitialized data section */
    .zero.table : ALIGN(4)
    {
        __zero_table_start__ = .;

        LONG(__bss_start__)                       /* Start of the zero-initialized data section */
        LONG((__bss_end__ - __bss_start__)/4)     /* Size of the zero-initialized data section in words */

        __zero_table_end__ = .;
    } > m33s_nvm_C_S

    /* A section for the veneer code of Secure APIs */
    .gnu.sgstubs : ALIGN(32)
    {
        _start_sg = .;

        *(.gnu.sgstubs*)
        . = ALIGN(32);

        _end_sg = .;
    } > m33s_nvm_C_S

    /* A section for the vector table */
    .ram_vectors (NOLOAD) : ALIGN(VECTORS_ALIGNMENT)
    {
        __ram_vectors_start__ = .;

        KEEP(*(.ram_vectors))

        __ram_vectors_end__ = .;
    } > m33s_data_S

    /* A section for initialized data memory */
    .data : ALIGN(4)
    {
        __data_start__ = .;

        *(.data*)
        KEEP(*(.jcr*))

        . = ALIGN(4);

        __data_end__ = .;
    } > m33s_data_S AT > m33s_nvm_C_S

    /* A section for non-initialized data memory */
    .bss(NOLOAD) : ALIGN(4)
    {
        __bss_start__ = .;

        *(.bss*)
        *(COMMON)

        . = ALIGN(4);

        __bss_end__ = .;
    } > m33s_data_S

    /* A section for variables that should not be initialized during the device startup */
    .noinit (NOLOAD) :
    {
        KEEP(*(.noinit))
    } > m33s_data_S

    /* A section for the heap memory */
    .heap(NOLOAD) : ALIGN(8)
    {
        __HeapBase = .;
        __end__ = .;
        end = __end__;

        KEEP(*(.heap*))

        . = ALIGN(8);
        . = ORIGIN(m33s_data_S) + LENGTH(m33s_data_S) - __StackSize;
        __HeapLimit = .;
    } > m33s_data_S

    /* A section for performance-sensitive or critical functions that need to be executed in SRAM */
    .app_code_ram : ALIGN(4)
    {
        __cy_sram0_code_vma_start__ = .;

        KEEP(*(.cy_ramfunc*))
        KEEP(*(.text.cy_os_common))
        *cy_syslib_ext.*(.text*)
        *cy_syslib.*(.text*)
        *cy_smif.*(.text*)
        *cy_smif_memslot.*(.text*)
        *cy_smif_sfdp.*(.text*)
        *cy_smif_hb_flash.*(.text*)
        *cyhal_qspi.*(.text*)
        *mtb_hal_memoryspi.*(.text*)
        *mtb_serial_memory.*(.text*)

        . = ALIGN(4);

        __cy_sram0_code_vma_end__ = .;
    } > m33s_code_C_S AT > m33s_nvm_C_S

    /* A section for secure shared RAM memory */
    .cy_sharedmem_sec (NOLOAD):
    {
        __sec_ram_start__ = .;

        KEEP(*(.cy_sharedmem_sec))

        __sec_ram_end__ = .;
    } > m33s_system_shared_S

    /* A section for public shared RAM memory */
    .cy_sharedmem(NOLOAD):
    {
        __public_ram_start__ = .;

        KEEP(*(.cy_sharedmem))

        __public_ram_end__ = .;
    } > core_shared_memory

    __StackTop = ORIGIN(m33s_data_S) + LENGTH(m33s_data_S);
    __StackLimit = __StackTop - __StackSize;
    PROVIDE(__stack = __StackTop);

    /* Check if data + heap + stack exceeds RAM limit */
    ASSERT(
        __StackLimit >= __HeapLimit,
        "Error: RAM region overflowed with stack. Ensure that the stack size is within the available RAM."
    )
}
